 Â¿En quÃ© formas JS puede manejar la asincronÃ­a?
 Callbacks:
 Una funciÃ³n que se pasa como argumento de otra funciÃ³n y que serÃ¡ invocada segÃºn sea su necesidad.
 Promesas (ES6):
 FunciÃ³n no-bloqueante y asÃ­ncrona la cual puede retornar un valor ahora, en el futuro o nunca.
 Async / Await (ES2017)
 Permite estructurar una funciÃ³n asincrÃ³nica sin bloqueo de una manera similar a una funciÃ³n sincrÃ³nica ordinaria.
 QuÃ© es el asincronismo 2/21 ğŸ¤¹ğŸ¾â€â™‚ï¸ . âœğŸ¾ ++Conceptos importantes para entender el asincronismo:++ . 
 ğŸ§µ Thread: Thread para Javascript permite realizar programaciÃ³n multihilos en este entorno. En realidad, simula la creaciÃ³n y ejecuciÃ³n de hilos, pero para el desarrollador es lo mismo. Ã‰sto simplifica muchÃ­simo la creaciÃ³n de aplicaciones Javascript. â€¢ 
 ğŸš« Bloqueante: Una llamada u operaciÃ³n bloqueante no devuelve el control a la aplicaciÃ³n hasta que se ha completado. Por tanto el thread queda bloqueado en estado de espera. 
 ğŸš¿ No bloqueante: Una tarea no bloqueante se devuelve inmediatamente con independencia del resultado. Si se completÃ³, devuelve los datos. Si no, un error. 
 ğŸï¸ SÃ­ncrono: Las tareas se ejecutan de forma secuencial, se debe esperar a que se complete para continuar con la siguiente tarea. 
 ğŸš¦ AsÃ­ncrono: Las tareas pueden ser realizadas mÃ¡s tarde, lo que hace posible que una respuesta sea procesada en diferido. La finalizaciÃ³n de la operaciÃ³n I/O (entrada/salida) se seÃ±aliza mÃ¡s tarde, mediante un mecanismo especÃ­fico como por ejemplo un callback, una promesa o un evento, lo que hace posible que la respuesta sea procesada en diferido. 
 ğŸ›¤ï¸ Paralelismo: El paralelismo es la ejecuciÃ³n simultÃ¡nea de dos o mÃ¡s tareas. Algunas tareas se pueden dividir en partes mÃ¡s pequeÃ±as que pueden ser resueltas simultÃ¡neamente. 
 ğŸ® Concurrencia: La concurrencia es la capacidad de un algoritmo o programa para ejecutar mÃ¡s de una tarea a la vez. El concepto es similar al procesamiento paralelo, pero con la posibilidad de que muchos trabajos independientes hagan diferentes cosas a la vez en lugar de ejecutar el mismo trabajo. 
 ğŸŒ€ Eventloop o Loop de eventos: El bucle de eventos es un patrÃ³n de diseÃ±o que espera y distribuye eventos o mensajes en un programa. . 
 ğŸ“ ++Formas de manejar la asincronÃ­a en JavaScript:++ . 
 ğŸ“© Callbacks: Una funciÃ³n que se pasa como argumento de otra funciÃ³n y que serÃ¡ invocada. 
 ğŸ«±ğŸ¼â€ğŸ«²ğŸ¾ Promesas: (implementado en ES6) Una promesa es una funciÃ³n no-bloqueante y asÃ­ncrona la cual puede retornar un valor ahora, en el futuro o nunca. 
 ğŸ›£ï¸ Async / Await: (implementado en ES2017) Permite estructurar una funciÃ³n asincrÃ³nica sin bloqueo de una manera similar a una funciÃ³n sincrÃ³nica ordinaria. 
 ğŸ“Œ En JavaScript casi todas las operaciones de I/O (Entrada y Salida) no se bloquean. A esto se le conoce como asÃ­ncronismo. Lo Ãºnico que no es procesado antes de que termine la operaciÃ³n son los callbacks, ya que Ã©stos estÃ¡n amarrados a una operaciÃ³n y esperan a que sea finalizada para poder ejecutarse. . â³ El asincronismo es una manera de aprovechar el tiempo y los recursos de la aplicaciÃ³n, ejecutando tareas y procesos mientras otros son resueltos en background (como la llegada de la informaciÃ³n de una API), para posteriormente continuar con las tareas que requerÃ­an esa informaciÃ³n que no tenÃ­as de manera instantÃ¡nea. . 
 â²ï¸ Un ejemplo fÃ¡cil de asincronismo vs sincronismo es invitar a unos amigos a una fiesta y ofrecer una parrillada. Primero decides colocar la carne y verduras a la parrilla y luego repartir bebidas y algo para picar (snacks). Si fuera ++una persona sÃ­ncrona++ (Blocking) tendrÃ­as que esperar a que la comida de la parrilla estÃ© cocinada y luego atender a los invitados. Pero si fuera ++una persona asÃ­ncrona++ (Non Blocking) luego de poner la carne al carbÃ³n, sacas las bebidas frÃ­as de la nevera y compartes con los invitados mientras se cocina la carne. La acciÃ³n de que la comida en la parrillada estÃ© lista serÃ­a ++un callback++ que estÃ¡ esperando que finalice el proceso para ejecutarse. Pero otros procesos (como compartir la velada con bebidas y algo de picar) ya podrÃ­an irse realizando.

 Web APIs JavaScript del lado del cliente: setTimeout, XMLHttpRequest, File Reader, DOM. Node: fs, https.


API: El tÃ©rmino API es una abreviatura de â€œApplication Programming Interfaceâ€ (Interfaz de programaciÃ³n de aplicaciones en espaÃ±ol). Es un conjunto de rutinas que provee acceso a funciones de un determinado software.
Hoisting: Sugiere que las declaraciones de variables y funciones son fÃ­sicamente movidas al comienzo del cÃ³digo en tiempo de compilaciÃ³n.

XML: Lenguaje de marcado creado para la transferencia de informaciÃ³n, legible tanto para seres humanos como para aplicaciones informÃ¡ticas, y basado en una sencillez extrema y una rÃ­gida sintaxis. AsÃ­ como el HTML estaba basado y era un subconjunto de SGML, la reformulaciÃ³n del primero bajo la sintaxis de XML dio lugar al XHTML; XHTML es, por tanto, un subconjunto de XML.

DOM: El DOM permite acceder y manipular las pÃ¡ginas XHTML como si fueran documentos XML. De hecho, DOM se diseÃ±Ã³ originalmente para manipular de forma sencilla los documentos XML.

Events: Comportamientos del usuario que interactÃºa con una pÃ¡gina que pueden detectarse para lanzar una acciÃ³n, como por ejemplo que el usuario haga click en un elemento (onclick), que elija una opciÃ³n de un desplegable (onselect), que pase el ratÃ³n sobre un objeto (onmouseover), etc.

Compilar: Compilar es generar cÃ³digo ejecutable por una mÃ¡quina, que puede ser fÃ­sica o abstracta como la mÃ¡quina virtual de Java.
Transpilar: Transpilar es generar a partir de cÃ³digo en un lenguaje cÃ³digo en otro lenguaje. Es decir, un programa produce otro programa en otro lenguaje cuyo comportamiento es el mismo que el original. . . ğŸ› ï¸ ++Crear e inicializar un Proyecto:++ .


ğ—¤ğ˜‚Ã© ğ˜€ğ—¼ğ—» ğ—¹ğ—®ğ˜€ ğ—½ğ—¿ğ—¼ğ—ºğ—²ğ˜€ğ—®ğ˜€ ğŸ­ğŸ¬/ğŸ®ğŸ­ ğŸ¤ğŸ¼ . ğŸªƒ Un ++callback++ devuelve una funciÃ³n en los parÃ¡metros, cuando llamamos varias veces un callback, estaremos colocando muchas lineas de cÃ³digo y serÃ­a engorroso, por eso nacen las promesas, Ã©stas optimizan y permiten leer mejor el cÃ³digo con pocas lineas. . ğŸ«±ğŸ¼â€ğŸ«²ğŸ¾ Las ++promesas++ son asÃ­ncronas, por lo que el cÃ³digo continuarÃ¡ su ejecuciÃ³n normalmente y luego dirÃ¡ si la promesa se resolviÃ³ o se rechazÃ³. Por lo que varias promesas pueden llegar a entrar en ejecuciÃ³n al mismo tiempo. . Las promesas pueden suceder: .

Ahora
En el futuro
Nunca .
ğŸ› ï¸ ++Para crear una promesa:++ . Utilizamos la palabra reservada new seguida de la palabra Promise que es el constructor de la promesa. Este constructor recibe un Ãºnico parÃ¡metro que es una funciÃ³n, la cuÃ¡l a su vez, recibe otros dos parÃ¡metros: resolve y reject.

El parÃ¡metro ++resolve++ se utiliza para cuando la promesa devuelve el valor correctamente.
El parÃ¡metro ++reject++, se usa en el que caso de que no funcione. . ğŸ“ ++Ejemplo:++

const promise = new Promise(function (resolve, reject){
resolve('hey!');
});
. ğŸ—ƒï¸ Una Promesa puede estar en uno de los siguientes estados: .

Pendiente pending â†’ Una promesa inicia en este estado: no cumplida, no rechazada:
Una promesa inicialmente estÃ¡ pendiente.
Cumplida fulfilled â†’ Significa que la operaciÃ³n se completÃ³ satisfactoriamente, .then(va => â€¦)
Cuando llamamos a resolve entonces la promesa pasa a estar resuelta.
Cuando una promesa se resuelve entonces se ejecuta la funciÃ³n que pasamos al mÃ©todo .then
Rechazada rejected â†’ significa que la operaciÃ³n fallÃ³, .catch(err => â€¦)
Si llamamos a reject pasa a estar rechazada (obtenemos un error que nos va a indicar la razÃ³n del rechazo).
Si la promesa es rechazada entonces se ejecuta la funciÃ³n que pasamos a .catch .
ğŸ“ ++Ejemplo con then y catch:++ .

Para probar el cÃ³digo, en el proyecto se crea la carpeta llamada ++promise++ dentro de la carpeta src.
Se crea el archivo ++index.js++ en la ruta: src/promise


ğ—šğ—²ğ—»ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿ğ˜€ ğŸ­ğŸ²/ğŸ®ğŸ­ ğŸ’¡ . Un ++generador++ en JavaScript consta de una funciÃ³n generadora que muestra un objeto iterable Generator. La palabra reservada yield se usa para pausar y reanudar una funciÃ³n generadora. Fuente: aquÃ­ .

La estructura del Generador consta con la palabra function seguido de un asterÃ­sco * : function* Ã©sta es una funciÃ³n generadora heredada.
El resultado que se quiere obtener se coloca al lado derecho de yield, puede ser de cualquier tipo (string, numÃ©rico, objetos, etc) y se puede tener tantos yield que se desee.